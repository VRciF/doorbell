
function json() {
/////////// strings.js

const getCharCode = (char) => char.charCodeAt(0);

/**
 * Turn a string into a typed array.
 * @param  {TypedArray} ArrayType - Bytes allocated per character.
 * @param  {String} chars - Restricted to common characters.
 * @return {Uint8Array} - Character codes mapped into a typed array.
 */
const encoder = (ArrayType) => (chars) => {
  const codes = chars.split('').map(getCharCode);
  const view = new ArrayType(codes.length);
  view.set(codes, 0);

  return view;
};

/**
 * Turns a buffer of single-byte character codes into a string.
 * @param  {TypedArray} ArrayType - Bytes allocated per character.
 * @param  {ArrayBuffer} buffer - String data.
 * @return {String} - The interpreted buffer.
 */
const decoder = (ArrayType) => (buffer) => {
  const view = new ArrayType(buffer);

  // Older browsers don't support iterable TypedArrays.
  const codes = Array.prototype.slice.call(view);

  return String.fromCharCode(...codes);
};

/**
 * Only handles small character codes (0-255). Used to encode
 * the buffer header, where each sub-buffer's length is stored.
 */
const small = {
  encode: encoder(Uint8Array),
  decode: decoder(Uint8Array),
};

/**
 * Handles text which can't fit in a single byte, like emojis or
 * chinese characters. Used to encode stringified JSON.
 */
const large = {
  encode: encoder(Uint16Array),
  decode: decoder(Uint16Array),
};

////////////// packager.js

/**
 * @private
 *
 * Utilities for concatenating Node buffers and typed arrays.
 * Buffers are encoded in the following format:
 *   [comma-separated buffer lengths][null byte delimiter][actual buffers]
 */

const getBufferLength = (buffer) => buffer.byteLength;
const addBufferSize = (acc, buffer) => acc + buffer.byteLength;

/**
 * Mostly the same as TypedArray#slice, but with browser support.
 * (IE, opera, & safari are problem customers).
 * @param  {TypedArray} view - Any of the typed arrays.
 * @param  {Number} start - A zero-based starting index.
 * @param  {Number} end - The ending index (exclusive).
 * @return {ArrayBuffer} - New buffer with the sliced values.
 */
const sliceBuffer = (view, start, end) => {
  const copy = new Uint8Array(end - start);

  for (let idx = start; idx < end; idx += 1) {
    copy[idx - start] = view[idx];
  }

  return copy.buffer;
};

/**
 * Basically TypedArray::findIndex, but with browser support.
 * @param  {TypedArray} buffer - Used to find the value index.
 * @param  {Number} value - A value to locate.
 * @return {Number} - The index, or -1 if not found.
 */
const findIndex = (buffer, value) => {
  for (let idx = 0; idx < buffer.byteLength; idx += 1) {
    if (buffer[idx] === value) {
      return idx;
    }
  }

  return -1;
};

/**
 * Take a list of buffers and copy them into a new buffer.
 * @param  {TypedArray[]} buffers - Typed arrays to join.
 * @return {ArrayBuffer} - All the binary data copied into a new buffer.
 */
const concatBuffers = (buffers) => {

  // Make a new buffer big enough to hold all the others.
  const size = buffers.reduce(addBufferSize, 0);
  const view = new Uint8Array(size);

  // Add the data from each buffer.
  buffers.reduce((cursor, buffer) => {

    // TypedArray#set() doesn't respect byte sizing.
    if (buffer.BYTES_PER_ELEMENT !== 1) {
      buffer = new Uint8Array(buffer.buffer);
    }

    view.set(buffer, cursor);
    return cursor + buffer.byteLength;
  }, 0);

  return view.buffer;
};

/**
 * Takes a list of buffers (or typed arrays) and combines them,
 * attaching metadata so they can be parsed out later.
 * @param  {TypedArray[]} buffers - Binary values to combine.
 * @return {ArrayBuffer} - A new buffer containing all the new values.
 */
const pack = (buffers) => {
  const lengths = buffers.map(getBufferLength).join(',');
  const header = small.encode(`${lengths}\0`);

  return concatBuffers([header].concat(buffers));
};

/**
 * Figures out what lengths the buffers are.
 * @param  {TypedArray} view - A previously packed ArrayBuffer view.
 * @param  {TypedArray} delimiter - A previously packed ArrayBuffer view.
 * @return {Number[]} - The lengths of each buffer.
 */
const getBufferLengths = (view, delimiter) => {
  const codes = sliceBuffer(view, 0, delimiter);
  const text = small.decode(codes);

  return text.split(',').map(Number);
};

/**
 * Pulls out a list of buffers from a packed buffer.
 * @param  {ArrayBuffer} buffer - Something generated by `pack(...)`.
 * @return {ArrayBuffer[]} - Unpacked buffers.
 */
const unpack = (buffer) => {
  const view = new Uint8Array(buffer);

  // Locate the null byte delimiter.
  const delimiter = findIndex(view, 0);

  // Find all the sub-buffers.
  const bufferLengths = getBufferLengths(view, delimiter);

  // Extract each sub-buffer.
  const { buffers } = bufferLengths.reduce(({ cursor, buffers }, length) => {
    const end = cursor + length;
    const buffer = sliceBuffer(view, cursor, end);

    return {
      buffers: buffers.concat(buffer),
      cursor: end,
    };
  }, {
    cursor: delimiter + 1,
    buffers: [],
  });

  return buffers;
};

/////////////// index.js

let BufferType = null;

/**
 * Sets a global buffer encoder. Useful in Node environments
 * or anywhere the `buffer` package is used.
 * @param  {Buffer|null} Buffer - A Node.js `Buffer` style interface.
 * @return {Object} - The json encoder/decoder.
 */
use = (Buffer) => {
  BufferType = Buffer;
};

SECRET_KEY = 'BIN_JSON_PNTR';

const BUFFER = 'Buffer';

/**
 * Detects if the value was a JSON-coerced Node-style buffer.
 * @param  {Any} value - Potential node buffer.
 * @return {Boolean} - Whether the value is a node buffer.
 */
const isNodeBuffer = (value) => Boolean(
  value.type === BUFFER &&
  value.data &&
  value.data.slice
);

/**
 * Determines if a value is an ArrayBuffer view.
 * @param  {Any} data - Anthing.
 * @return {Boolean} - True for typed arrays, false for anything else.
 */
const isBuffer = (data) => {
  if (!data) {
    return false;
  }

  // Typed arrays.
  if (data.buffer instanceof ArrayBuffer) {
    return true;
  }

  // Workaround for Node-style Buffers.
  if (isNodeBuffer(data)) {
    return true;
  }

  return false;
};

// TypedArray constants.
const bufferTypes = {
  i8: 1,
  ui16: 2,
  i16: 3,
  ui32: 4,
  i32: 5,
  f32: 6,
  f64: 7,
};

// Map constants to TypedArray constructors.
const arrayTypes = {
  [bufferTypes.i8]: Int8Array,
  [bufferTypes.ui16]: Uint16Array,
  [bufferTypes.i16]: Int16Array,
  [bufferTypes.ui32]: Uint32Array,
  [bufferTypes.i32]: Int32Array,
  [bufferTypes.f32]: Float32Array,
  [bufferTypes.f64]: Float64Array,
};

/**
 * Turn a TypedArray instance into a constant representing its type.
 * @param  {TypedArray} buffer - Any typed array.
 * @return {Number|null} - A numerical constant, or null for the default.
 */
const getBufferType = (buffer) => {
  switch (buffer.constructor) {
  case Int8Array: return bufferTypes.i8;
  case Uint16Array: return bufferTypes.ui16;
  case Int16Array: return bufferTypes.i16;
  case Uint32Array: return bufferTypes.ui32;
  case Int32Array: return bufferTypes.i32;
  case Float32Array: return bufferTypes.f32;
  case Float64Array: return bufferTypes.f64;
  default: return null;
  }
};

/**
 * Reconstructs a buffer view using the original encoding.
 * If `json.Buffer` is set, it constructs it using that.
 * @param  {String} [type] - A constant representing the array type.
 * @param  {ArrayBuffer} buffer - Any binary data.
 * @return {TypedArray|json.Buffer} - A typed array or json.Buffer instance.
 */
const createBufferView = (type, buffer) => {
  const TypedArray = arrayTypes[type] || Uint8Array;
  const view = new TypedArray(buffer);
  return BufferType ? BufferType.from(view) : view;
};

/**
 * Stringifies JSON data and leaves a pointer where binary values were.
 * @param  {Mixed} data - Any JSON compatible data (or binary).
 * @return {Object} data.json - The stringified json data.
 * @return {Object} data.buffers - A list of extracted buffers.
 */
const serialize = (data) => {
  const buffers = [];

  const json = JSON.stringify(data, (key, value) => {
    if (!isBuffer(value)) {
      return value;
    }

    // `JSON.stringify` calls `.toJSON` on buffers before
    // this function sees them, which turns the ArrayBuffer
    // into a JS array. I'm not sure if there's a cleaner way to handle this.
    if (isNodeBuffer(value)) {
      value = new Uint8Array(value.data);
    }

    const index = buffers.push(value) - 1;

    // Remember the TypedArray kind.
    const bufferType = getBufferType(value);
    const pointer = bufferType ? [index, bufferType] : [index];

    return { [SECRET_KEY]: pointer };
  });

  return { buffers, json };
};

/**
 * Turns JSON data (possibly intermixed with binary) into a buffer.
 * If the data is `undefined`, you'll get `undefined` back.
 * @param  {Mixed} data - Supports JSON datatypes & binary.
 * @return {ArrayBuffer|void} - An array buffer representing the given data.
 */
encode = (data) => {
  if (data === undefined) {
    return data;
  }

  const { json, buffers } = serialize(data);
  const everything = buffers.concat(large.encode(json));
  const buffer = pack(everything);

  // Some Node APIs don't recognize ArrayBuffers (e.g., zlib).
  // If `json.Buffer` is set, it gives better Node interop.
  return BufferType ? BufferType.from(buffer) : buffer;
};

/**
 * Creates a function which reassembles the json and buffer data.
 * @param  {ArrayBuffer[]} buffers - Every unpacked buffer except the JSON.
 * @param  {String} [key] - Name of the value property (given by JSON.parse()).
 * @param  {Mixed} value - A json datatype.
 * @return {Mixed} - Either the same json value or a new buffer.
 */
const deserialize = (buffers) => (key, value) => {
  if (!value) {
    return value;
  }

  if (!value[SECRET_KEY]) {
    return value;
  }

  const [index, TYPE] = value[SECRET_KEY];

  if (index in buffers) {

    // Reconstruct the data in the original buffer view.
    return createBufferView(TYPE, buffers[index]);
  }

  return value;
};

/**
 * Turns the ArrayBuffer created by `json.encode` back into json.
 * @param  {ArrayBuffer} buffer - Must be a buffer created by `json.encode`.
 * @return {Mixed} - The JSON data, binary values included :tada:
 */
decode = (buffer) => {
  const typeName = typeof buffer;
  const isObject = typeName === 'object' && !!buffer;

  // Do some validation.
  if (buffer === '[object ArrayBuffer]') {
    throw new TypeError(
      'Hmmm, bin-json.decode(...) was given "[object ArrayBuffer]".\n' +
      'Double check that your encoded data is being handled correctly.'
    );
  }

  if (!isObject) {
    const type = typeName === 'object' ? String(buffer) : typeName;
    throw new TypeError(
      `bin-json.decode() expects a buffer, but was given "${type}".`
    );
  }

  const parsed = unpack(buffer);
  const buffers = parsed.slice(0, -1);
  const deserializer = deserialize(buffers);

  const json = parsed[parsed.length - 1];
  const string = large.decode(json);

  return JSON.parse(string, deserializer);
};

return {decode: decode, encode:encode};
}
