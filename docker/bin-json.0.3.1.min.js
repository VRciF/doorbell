(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _arrayTypes;

var _packager = require('./packager');

var _strings = require('./strings');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var BufferType = null;

/**
 * Sets a global buffer encoder. Useful in Node environments
 * or anywhere the `buffer` package is used.
 * @param  {Buffer|null} Buffer - A Node.js `Buffer` style interface.
 * @return {Object} - The json encoder/decoder.
 */
exports.use = function (Buffer) {
  BufferType = Buffer;
};

exports.SECRET_KEY = 'BIN_JSON_PNTR';

var BUFFER = 'Buffer';

/**
 * Detects if the value was a JSON-coerced Node-style buffer.
 * @param  {Any} value - Potential node buffer.
 * @return {Boolean} - Whether the value is a node buffer.
 */
var isNodeBuffer = function isNodeBuffer(value) {
  return Boolean(value.type === BUFFER && value.data && value.data.slice);
};

/**
 * Determines if a value is an ArrayBuffer view.
 * @param  {Any} data - Anthing.
 * @return {Boolean} - True for typed arrays, false for anything else.
 */
var isBuffer = function isBuffer(data) {
  if (!data) {
    return false;
  }

  // Typed arrays.
  if (data.buffer instanceof ArrayBuffer) {
    return true;
  }

  // Workaround for Node-style Buffers.
  if (isNodeBuffer(data)) {
    return true;
  }

  return false;
};

// TypedArray constants.
var bufferTypes = {
  i8: 1,
  ui16: 2,
  i16: 3,
  ui32: 4,
  i32: 5,
  f32: 6,
  f64: 7
};

// Map constants to TypedArray constructors.
var arrayTypes = (_arrayTypes = {}, _defineProperty(_arrayTypes, bufferTypes.i8, Int8Array), _defineProperty(_arrayTypes, bufferTypes.ui16, Uint16Array), _defineProperty(_arrayTypes, bufferTypes.i16, Int16Array), _defineProperty(_arrayTypes, bufferTypes.ui32, Uint32Array), _defineProperty(_arrayTypes, bufferTypes.i32, Int32Array), _defineProperty(_arrayTypes, bufferTypes.f32, Float32Array), _defineProperty(_arrayTypes, bufferTypes.f64, Float64Array), _arrayTypes);

/**
 * Turn a TypedArray instance into a constant representing its type.
 * @param  {TypedArray} buffer - Any typed array.
 * @return {Number|null} - A numerical constant, or null for the default.
 */
var getBufferType = function getBufferType(buffer) {
  switch (buffer.constructor) {
    case Int8Array:
      return bufferTypes.i8;
    case Uint16Array:
      return bufferTypes.ui16;
    case Int16Array:
      return bufferTypes.i16;
    case Uint32Array:
      return bufferTypes.ui32;
    case Int32Array:
      return bufferTypes.i32;
    case Float32Array:
      return bufferTypes.f32;
    case Float64Array:
      return bufferTypes.f64;
    default:
      return null;
  }
};

/**
 * Reconstructs a buffer view using the original encoding.
 * If `json.Buffer` is set, it constructs it using that.
 * @param  {String} [type] - A constant representing the array type.
 * @param  {ArrayBuffer} buffer - Any binary data.
 * @return {TypedArray|json.Buffer} - A typed array or json.Buffer instance.
 */
var createBufferView = function createBufferView(type, buffer) {
  var TypedArray = arrayTypes[type] || Uint8Array;
  var view = new TypedArray(buffer);
  return BufferType ? BufferType.from(view) : view;
};

/**
 * Stringifies JSON data and leaves a pointer where binary values were.
 * @param  {Mixed} data - Any JSON compatible data (or binary).
 * @return {Object} data.json - The stringified json data.
 * @return {Object} data.buffers - A list of extracted buffers.
 */
var serialize = function serialize(data) {
  var buffers = [];

  var json = JSON.stringify(data, function (key, value) {
    if (!isBuffer(value)) {
      return value;
    }

    // `JSON.stringify` calls `.toJSON` on buffers before
    // this function sees them, which turns the ArrayBuffer
    // into a JS array. I'm not sure if there's a cleaner way to handle this.
    if (isNodeBuffer(value)) {
      value = new Uint8Array(value.data);
    }

    var index = buffers.push(value) - 1;

    // Remember the TypedArray kind.
    var bufferType = getBufferType(value);
    var pointer = bufferType ? [index, bufferType] : [index];

    return _defineProperty({}, exports.SECRET_KEY, pointer);
  });

  return { buffers: buffers, json: json };
};

/**
 * Turns JSON data (possibly intermixed with binary) into a buffer.
 * If the data is `undefined`, you'll get `undefined` back.
 * @param  {Mixed} data - Supports JSON datatypes & binary.
 * @return {ArrayBuffer|void} - An array buffer representing the given data.
 */
exports.encode = function (data) {
  if (data === undefined) {
    return data;
  }

  var _serialize = serialize(data),
      json = _serialize.json,
      buffers = _serialize.buffers;

  var everything = buffers.concat(_strings.large.encode(json));
  var buffer = (0, _packager.pack)(everything);

  // Some Node APIs don't recognize ArrayBuffers (e.g., zlib).
  // If `json.Buffer` is set, it gives better Node interop.
  return BufferType ? BufferType.from(buffer) : buffer;
};

/**
 * Creates a function which reassembles the json and buffer data.
 * @param  {ArrayBuffer[]} buffers - Every unpacked buffer except the JSON.
 * @param  {String} [key] - Name of the value property (given by JSON.parse()).
 * @param  {Mixed} value - A json datatype.
 * @return {Mixed} - Either the same json value or a new buffer.
 */
var deserialize = function deserialize(buffers) {
  return function (key, value) {
    if (!value) {
      return value;
    }

    if (!value[exports.SECRET_KEY]) {
      return value;
    }

    var _value$exports$SECRET = _slicedToArray(value[exports.SECRET_KEY], 2),
        index = _value$exports$SECRET[0],
        TYPE = _value$exports$SECRET[1];

    if (index in buffers) {

      // Reconstruct the data in the original buffer view.
      return createBufferView(TYPE, buffers[index]);
    }

    return value;
  };
};

/**
 * Turns the ArrayBuffer created by `json.encode` back into json.
 * @param  {ArrayBuffer} buffer - Must be a buffer created by `json.encode`.
 * @return {Mixed} - The JSON data, binary values included :tada:
 */
exports.decode = function (buffer) {
  var typeName = typeof buffer === 'undefined' ? 'undefined' : _typeof(buffer);
  var isObject = typeName === 'object' && !!buffer;

  // Do some validation.
  if (buffer === '[object ArrayBuffer]') {
    throw new TypeError('Hmmm, bin-json.decode(...) was given "[object ArrayBuffer]".\n' + 'Double check that your encoded data is being handled correctly.');
  }

  if (!isObject) {
    var type = typeName === 'object' ? String(buffer) : typeName;
    throw new TypeError('bin-json.decode() expects a buffer, but was given "' + type + '".');
  }

  var parsed = (0, _packager.unpack)(buffer);
  var buffers = parsed.slice(0, -1);
  var deserializer = deserialize(buffers);

  var json = parsed[parsed.length - 1];
  var string = _strings.large.decode(json);

  return JSON.parse(string, deserializer);
};
},{"./packager":2,"./strings":3}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unpack = exports.pack = undefined;

var _strings = require('./strings');

var getBufferLength = function getBufferLength(buffer) {
  return buffer.byteLength;
}; /**
    * @private
    *
    * Utilities for concatenating Node buffers and typed arrays.
    * Buffers are encoded in the following format:
    *   [comma-separated buffer lengths][null byte delimiter][actual buffers]
    */

var addBufferSize = function addBufferSize(acc, buffer) {
  return acc + buffer.byteLength;
};

/**
 * Mostly the same as TypedArray#slice, but with browser support.
 * (IE, opera, & safari are problem customers).
 * @param  {TypedArray} view - Any of the typed arrays.
 * @param  {Number} start - A zero-based starting index.
 * @param  {Number} end - The ending index (exclusive).
 * @return {ArrayBuffer} - New buffer with the sliced values.
 */
var sliceBuffer = function sliceBuffer(view, start, end) {
  var copy = new Uint8Array(end - start);

  for (var idx = start; idx < end; idx += 1) {
    copy[idx - start] = view[idx];
  }

  return copy.buffer;
};

/**
 * Basically TypedArray::findIndex, but with browser support.
 * @param  {TypedArray} buffer - Used to find the value index.
 * @param  {Number} value - A value to locate.
 * @return {Number} - The index, or -1 if not found.
 */
var findIndex = function findIndex(buffer, value) {
  for (var idx = 0; idx < buffer.byteLength; idx += 1) {
    if (buffer[idx] === value) {
      return idx;
    }
  }

  return -1;
};

/**
 * Take a list of buffers and copy them into a new buffer.
 * @param  {TypedArray[]} buffers - Typed arrays to join.
 * @return {ArrayBuffer} - All the binary data copied into a new buffer.
 */
var concatBuffers = function concatBuffers(buffers) {

  // Make a new buffer big enough to hold all the others.
  var size = buffers.reduce(addBufferSize, 0);
  var view = new Uint8Array(size);

  // Add the data from each buffer.
  buffers.reduce(function (cursor, buffer) {

    // TypedArray#set() doesn't respect byte sizing.
    if (buffer.BYTES_PER_ELEMENT !== 1) {
      buffer = new Uint8Array(buffer.buffer);
    }

    view.set(buffer, cursor);
    return cursor + buffer.byteLength;
  }, 0);

  return view.buffer;
};

/**
 * Takes a list of buffers (or typed arrays) and combines them,
 * attaching metadata so they can be parsed out later.
 * @param  {TypedArray[]} buffers - Binary values to combine.
 * @return {ArrayBuffer} - A new buffer containing all the new values.
 */
var pack = exports.pack = function pack(buffers) {
  var lengths = buffers.map(getBufferLength).join(',');
  var header = _strings.small.encode(lengths + '\0');

  return concatBuffers([header].concat(buffers));
};

/**
 * Figures out what lengths the buffers are.
 * @param  {TypedArray} view - A previously packed ArrayBuffer view.
 * @param  {TypedArray} delimiter - A previously packed ArrayBuffer view.
 * @return {Number[]} - The lengths of each buffer.
 */
var getBufferLengths = function getBufferLengths(view, delimiter) {
  var codes = sliceBuffer(view, 0, delimiter);
  var text = _strings.small.decode(codes);

  return text.split(',').map(Number);
};

/**
 * Pulls out a list of buffers from a packed buffer.
 * @param  {ArrayBuffer} buffer - Something generated by `pack(...)`.
 * @return {ArrayBuffer[]} - Unpacked buffers.
 */
var unpack = exports.unpack = function unpack(buffer) {
  var view = new Uint8Array(buffer);

  // Locate the null byte delimiter.
  var delimiter = findIndex(view, 0);

  // Find all the sub-buffers.
  var bufferLengths = getBufferLengths(view, delimiter);

  // Extract each sub-buffer.

  var _bufferLengths$reduce = bufferLengths.reduce(function (_ref, length) {
    var cursor = _ref.cursor,
        buffers = _ref.buffers;

    var end = cursor + length;
    var buffer = sliceBuffer(view, cursor, end);

    return {
      buffers: buffers.concat(buffer),
      cursor: end
    };
  }, {
    cursor: delimiter + 1,
    buffers: []
  }),
      buffers = _bufferLengths$reduce.buffers;

  return buffers;
};
},{"./strings":3}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var getCharCode = function getCharCode(char) {
  return char.charCodeAt(0);
};

/**
 * Turn a string into a typed array.
 * @param  {TypedArray} ArrayType - Bytes allocated per character.
 * @param  {String} chars - Restricted to common characters.
 * @return {Uint8Array} - Character codes mapped into a typed array.
 */
var encoder = function encoder(ArrayType) {
  return function (chars) {
    var codes = chars.split('').map(getCharCode);
    var view = new ArrayType(codes.length);
    view.set(codes, 0);

    return view;
  };
};

/**
 * Turns a buffer of single-byte character codes into a string.
 * @param  {TypedArray} ArrayType - Bytes allocated per character.
 * @param  {ArrayBuffer} buffer - String data.
 * @return {String} - The interpreted buffer.
 */
var decoder = function decoder(ArrayType) {
  return function (buffer) {
    var view = new ArrayType(buffer);

    // Older browsers don't support iterable TypedArrays.
    var codes = Array.prototype.slice.call(view);

    return String.fromCharCode.apply(String, _toConsumableArray(codes));
  };
};

/**
 * Only handles small character codes (0-255). Used to encode
 * the buffer header, where each sub-buffer's length is stored.
 */
var small = exports.small = {
  encode: encoder(Uint8Array),
  decode: decoder(Uint8Array)
};

/**
 * Handles text which can't fit in a single byte, like emojis or
 * chinese characters. Used to encode stringified JSON.
 */
var large = exports.large = {
  encode: encoder(Uint16Array),
  decode: decoder(Uint16Array)
};
},{}]},{},[1]);
